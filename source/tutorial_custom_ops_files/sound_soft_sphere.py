#!/usr/bin/env python

# This script uses BEM++ to solve a Helmholtz transmission problem. It
# calculates the field generated by a plane wave impinging on a
# permeable sphere from the -x direction.

# PART 0: Set global options ###################################################
useCustomOperator = True
# edit to suit your needs
bemppInstallPrefix = "/Users/wojtek/Projects/BEM/bempp-1.1/bempp/install/"

# PART 1: Import the necessary modules #########################################

import sys
sys.path.append(bemppInstallPrefix + "bempp/python")

import numpy as np
from bempp import lib
if useCustomOperator:
    from bempp import combined_helmholtz

# PART 2: Set quadrature and assembly options ##################################

# Create a quadrature strategy

accuracyOptions = lib.createAccuracyOptions()
accuracyOptions.doubleRegular.setRelativeQuadratureOrder(2)
accuracyOptions.singleRegular.setRelativeQuadratureOrder(2)
quadStrategy = lib.createNumericalQuadratureStrategy(
    "float64", "complex128", accuracyOptions)

# Set assembly options -- switch to ACA

options = lib.createAssemblyOptions()
options.switchToAca(lib.createAcaOptions())

# Combine the quadrature strategy and assembly options into an assembly context

context = lib.createContext(quadStrategy, options)

# PART 3: Define the system of integral equations to be solved #################

# Import mesh

grid = lib.createGridFactory().importGmshGrid(
    "triangular", bemppInstallPrefix + "bempp/examples/meshes/sphere-h-0.1.msh")

# Create a function space

pconsts = lib.createPiecewiseConstantScalarSpace(context, grid)

# Define material and wave parameters

k = 5.

# Create boundary operators

if useCustomOperator:
    cpOp = combined_helmholtz.createHelmholtz3dCombinedBoundaryOperator(
        context, pconsts, pconsts, pconsts, k, "CP")
    idOp = lib.createIdentityOperator(
        context, pconsts, pconsts, pconsts, "Id")
    lhsOp =  0.5 * idOp + cpOp
else:
    slpOp = lib.createHelmholtz3dSingleLayerBoundaryOperator(
        context, pconsts, pconsts, pconsts, k, "SLP")
    dlpOp = lib.createHelmholtz3dDoubleLayerBoundaryOperator(
        context, pconsts, pconsts, pconsts, k, "DLP")
    idOp = lib.createIdentityOperator(
        context, pconsts, pconsts, pconsts, "Id")
    lhsOp =  0.5 * idOp + dlpOp - 1j * k *slpOp

# Create a grid function representing the Dirichlet trace of the incident wave

def uIncData(point):
    x, y, z = point
    r = np.sqrt(x**2 + y**2 + z**2)
    return np.exp(1j * k * x)

# def uIncData(point, normal):
#     x, y, z = point
#     nx, ny, nz = normal
#     r = np.sqrt(x**2 + y**2 + z**2)
#     return 1j * k * np.exp(1j * k * x) * (nx - 1.);

uInc = lib.createGridFunction(context, pconsts, pconsts, uIncData)

# Create a grid function representing the Neumann trace of the incident wave

def uIncDerivData(point, normal):
    x, y, z = point
    nx, ny, nz = normal
    r = np.sqrt(x**2 + y**2 + z**2)
    return 1j * k * np.exp(1j * k * x) * nx

uIncDeriv = lib.createGridFunction(context, pconsts, pconsts, uIncDerivData,
                                   surfaceNormalDependent=True)

# Create elements of the right hand side of the equation

rhs = uIncDeriv - 1j * k * uInc

# PART 4: Discretize and solve the equations ###################################

# Create a GMRES solver

solver = lib.createDefaultIterativeSolver(lhsOp)
params = lib.defaultGmresParameterList(1e-8)
solver.initializeSolver(params)

# Solve the equation

solution = solver.solve(rhs)
print solution.solverMessage()

# PART 5: Extract the solution #################################################

# Extract the solution components (Dirichlet and Neumann traces of the
# total field)

uExtDeriv = solution.gridFunction()

# Combine them with the incident wave to yield the traces of the scattered field
# (uSc) and the field transmitted into the object (uInt)

uSc = -uInc
uScDeriv = uExtDeriv - uIncDeriv

# PART 6: Evaluate the total field on part of the xy plane #####################

# Create the potential operators entering the Green's representation formula

slPot = lib.createHelmholtz3dSingleLayerPotentialOperator(context, k)
dlPot = lib.createHelmholtz3dDoubleLayerPotentialOperator(context, k)

# Create a grid of points

nPointsX = 201
nPointsY = 201
x, y, z = np.mgrid[-5:5:nPointsX*1j, -5:5:nPointsY*1j, 0:0:1j]
points = np.vstack((x.ravel(), y.ravel(), z.ravel()))

# Split the points into those located inside and outside the scatterer

inside = lib.areInside(grid, points)
outside = np.logical_not(inside)

# Use Green's representation formulas to evaluate the total field
# outside the scatterer

evalOptions = lib.createEvaluationOptions()
valsExt = (- slPot.evaluateAtPoints(uScDeriv, points[:,outside], evalOptions)
           + dlPot.evaluateAtPoints(uSc, points[:,outside], evalOptions)
           + uIncData(points[:,outside]))

# Combine the results obtained for points inside and outside the scatterer
# in a single array

vals = np.zeros(nPointsX * nPointsY, dtype=complex)
np.place(vals, outside, valsExt.ravel())

# Display the field plot

from bempp import visualization as vis
uActor = vis.scalarDataOnRegularGridActor(
        points, vals, (nPointsX, nPointsY), transformation="abs")
legendActor = vis.legendActor(uActor)
gridActor = vis.gridActor(grid)
vis.plotTvtkActors([uActor, gridActor, legendActor])

# Export the results into a VTK file

from tvtk.api import write_data
write_data(uActor.mapper.input_as_data_set, "u.vts")

# PART 6: Evaluate the far-field pattern of the scattered field ################

# Create the necessary potential operators

slFfPot = lib.createHelmholtz3dFarFieldSingleLayerPotentialOperator(context, k)
dlFfPot = lib.createHelmholtz3dFarFieldDoubleLayerPotentialOperator(context, k)

# Define a set of points on the unit sphere and evaluate the potentials

theta = np.linspace(0, 2*np.pi, 361)
points = np.vstack([np.cos(theta), np.sin(theta), 0. * theta])

farFieldPattern = (- slFfPot.evaluateAtPoints(uScDeriv, points, evalOptions)
                   + dlFfPot.evaluateAtPoints(uSc, points, evalOptions))
farFieldPattern = farFieldPattern.ravel()

# Display the graph

import pylab
pylab.polar(theta, abs(farFieldPattern))
pylab.title("Scattered field pattern")
pylab.show()
